"""
#####################################################
#                                                   #
# CIRCLEMETER   gDesklets Display                   #
#                                                   #
# This is the scripting work behind the circle      #
# meter display.                                    #
#                                                   #
# (c) Ronny Lorenz 2012                             #
#                                                   #
#####################################################
"""

"""
#####################################################
#                                                   #
# The next block of variables contains the default  #
# values for a circle meter. Change them if you are #
# not happy with the default                        #
#                                                   #
#####################################################
"""
INIT_NAME               = "CPU Load Meter"
INIT_BIND               = "cpu_load"
INIT_LOAD               = 100           # A meter starts with 100% load
INIT_ROTATION           = 135           # angular rotation of the first element
INIT_ORIGIN_X           = 50            # do not change this value
INIT_ORIGIN_Y           = 50            # do not change this value
INIT_RADIUS_X           = 40            # x radius 
INIT_RADIUS_Y           = 40            # y radius
INIT_MAX_ROTATION       = 270           # maximum angular resolution (in range 0:360
INIT_SEGMENT_NUMBER     = 30            # number of segments in the meter
INIT_SEGMENT_THICKNESS  = 7             # thickness of a segment
INIT_COLOR_MIN          = "#00ff00ff"   # color for the minimum value (i.e. 0.)
INIT_COLOR_MEAN         = "#ffff00ff"   # color for the mean value
INIT_COLOR_MAX          = "#ff0000ff"   # color for the maximum value (i.e. 100.)
INIT_COLOR_MEAN_VALUE   = 40            # mean value
INIT_LABEL_FONT         = ""
INIT_LABEL_COLOR        = "#ff0000ff"
INIT_FIXED_COLOR        = False         # use fixed color for meter label or not
INIT_CLOCKWISE          = True          # direction of the meter (1 = clockwise, -1 = counterclockwise)

update_interval = 750


"""
#####################################################
#                                                   #
# All variables below are for internal function use #
# only and should never be changed                  #
#                                                   #
#####################################################
"""

pi            = 3.14159265358979323846
meter_objects = []
meter_configs = []
SVG_PATH      = "<path  id=\"bar_%d\"\
                        d=\"M%3.4f,%3.4f L%3.4f %3.4f A%d,%d 0 0,1 %3.4f,%3.4f L%3.4f %3.4f A%d,%d 0 0,0 %3.4f,%3.4f z\"\
                        fill=\"#333344\"\
                        stroke=\"#666666\"\
                        stroke-width=\"1\"/>"

#
# Values below are used as bindings for the appropriate prefs dialogs
#
curr_meter          = "0"
init_rotation       = INIT_ROTATION
origin_x            = INIT_ORIGIN_X
origin_y            = INIT_ORIGIN_Y
radius_x            = INIT_RADIUS_X
radius_y            = INIT_RADIUS_Y
max_rotation        = INIT_MAX_ROTATION
number_of_segments  = INIT_SEGMENT_NUMBER
segment_thickness   = INIT_SEGMENT_THICKNESS
color_min           = INIT_COLOR_MIN
color_mean          = INIT_COLOR_MEAN
color_max           = INIT_COLOR_MAX
mean_value          = INIT_COLOR_MEAN_VALUE
fixed_font_color    = INIT_FIXED_COLOR
meter_direction     = bool(INIT_CLOCKWISE)
label_color         = INIT_LABEL_COLOR
label_font          = ""

"""
#####################################################
#                                                   #
# Beginning of function code                        #
#                                                   #
#####################################################
"""

def main():
    global meter_configs
    global meter_objects
    global curr_meter

    meter_configs = get_config( "meter_configs", "nothing found")

    if meter_configs is not "nothing found":
        restore_from_configs()
    else:
        # create a default meter from scratch
        meter_objects = []
        meter = SysMeter(INIT_NAME)
        meter.init_svg()
        meter_objects.append(meter)

    for idx in range(len(meter_objects)):
        UpdateMeterPosition(idx)

    update_meter_enum()
    set_prefs_values() # we should always have at least one meter

    add_timer(update_interval, update_loads)

# def extract_memory_information():
#  """
#  Struct { .buffer = 99209216, .cached = 1320513536, .free = 194740224, .locked = 0,   
#  .shared = 0, .total = 2124939264, .used = 1930199040, .user = 510476288 }
#  """
#  return

def UpdateMeterPosition(idx):
    try:
        getattr(Dsp, "CircleMeterLabel")[idx].x = Unit(50, PERCENT) 
        getattr(Dsp, "CircleMeterLabel")[idx].y = Unit(50, PERCENT)
    except:
        print "Warning! Could not update CircleMeter %d's position" % idx


def update_loads():
    # put all possible ressources that should be displayable down here
    for i in range(len(meter_objects)):
        value = -1.
        # check whether we display the cpu load or not
        if meter_objects[i]._bind == "cpu_load":
            value = float(sysinfo.cpu_load)

        # if we dont know what to do we do nothing but warn
        else:
            print "Warning! Ressource %s not covered by update process" % meter_objects[i]._bind

        if value >= 0.:
            meter_objects[i]._load = value
            meter_objects[i].update_meter()
            getattr(Dsp, "CircleMeterLabel")[0].value = "%3.2f%%" % value

    return True

def sine(alpha):
    alpha_rad = pi * (alpha - 360.0 * int(alpha/360))/180
    if alpha_rad >= pi:
        alpha_rad -= 2*pi
    return alpha_rad - (alpha_rad**3)/6 + (alpha_rad**5)/120 - (alpha_rad**7)/5040 + (alpha_rad**9)/362880 #- (alpha_rad**11)/39916800

def cosine(alpha):
    return sine(alpha + 90.0)

"""
#####################################################
#                                                   #
# Config store/restore                              #
#                                                   #
#####################################################
"""

# a list of all attributes that may be set by setAttribute() method of Meter objects
CircleMeterAttributeList =  [ "name",
                              "bind",
                              "init_rotation",
                              "radius_x",
                              "radius_y",
                              "max_rotation",
                              "number_of_segments",
                              "segment_thickness",
                              "color_min",
                              "color_mean",
                              "color_max",
                              "mean_value",
                              "fixed_font_color",
                              "meter_direction",
                              "label_font",
                              "label_color"
                            ]

def save_configurations():
    global meter_configs

    meter_configs = []
    for idx in range(len(meter_objects)):
        config_string = (\
                          str(meter_objects[idx]._name),\
                          str(meter_objects[idx]._bind),\
                          int(meter_objects[idx]._init_rotation),\
                          int(meter_objects[idx]._radius_x),\
                          int(meter_objects[idx]._radius_y),\
                          int(meter_objects[idx]._max_rotation),\
                          int(meter_objects[idx]._number_of_segments),\
                          int(meter_objects[idx]._segment_thickness),\
                          str(meter_objects[idx]._color_min),\
                          str(meter_objects[idx]._color_mean),\
                          str(meter_objects[idx]._color_max),\
                          int(meter_objects[idx]._mean_value),\
                          bool(meter_objects[idx]._fixed_font_color),\
                          bool(meter_objects[idx]._direction),\
                          str(meter_objects[idx]._label_font),\
                          str(meter_objects[idx]._label_font)
                        )
        meter_configs.append(config_string)

    set_config("meter_configs", meter_configs)



def restore_from_configs():
    global meter_objects

    # destroy all existing meters
    meter_objects = []

    # recreate new meters from config
    for i in range(len(meter_configs)):
        print "Init %d. Circle Meter: \"%s\" (from stored config)" % (i+1, (meter_configs[i][0]))
        meter = SysMeter(meter_configs[i][0]) # call the constructor with the name of the meter
        for k, v in zip(CircleMeterAttributeList, meter_configs[i]):
            meter.setAttribute(k, v)
        meter.init_svg()
        meter_objects.append(meter)

"""
#####################################################
#                                                   #
# Preferences callback and other Prefs functions    #
#                                                   #
#####################################################
"""

def update_meter_enum():
    Prefs.meter_enum.items =  [ ("%s" % meter_objects[i]._name, str(i)) for i in range(len(meter_objects)) ]

def set_prefs_values():
    idx = int(curr_meter)

    Prefs.init_rotation.value       = int(meter_objects[idx]._init_rotation)
    Prefs.radius_x.value            = int(meter_objects[idx]._radius_x)
    Prefs.radius_y.value            = int(meter_objects[idx]._radius_y)
    Prefs.max_rotation.value        = int(meter_objects[idx]._max_rotation)
    Prefs.number_of_segments.value  = int(meter_objects[idx]._number_of_segments)
    Prefs.segment_thickness.value   = int(meter_objects[idx]._segment_thickness)
    Prefs.color_min.value           = meter_objects[idx]._color_min
    Prefs.color_mean.value          = meter_objects[idx]._color_mean
    Prefs.color_max.value           = meter_objects[idx]._color_max
    Prefs.mean_value.value          = int(meter_objects[idx]._mean_value)
    Prefs.fixed_font_color.value    = bool(meter_objects[idx]._fixed_font_color)
    Prefs.clockwise.value           = bool(meter_objects[idx]._direction)

def preferences_callback(key, value):
    global curr_meter

    idx = int(curr_meter)

    if key == "curr_meter":
        curr_meter = value
        set_prefs_values()

    elif key == "update_interval":
        cpu_meter_update_interval = value

    elif meter_objects[idx].setAttribute(key, value):
        meter_objects[idx].init_svg()

    else:
        print "Warning! Unknown prefs: %s=%s" % (key, value)

    if key == "fixed_font_color":
        Prefs.fixed_font_color_color.enabled = value

    save_configurations()

"""
#####################################################
#                                                   #
# Meter object class definition                     #
#                                                   #
#####################################################
"""
class SysMeter:
    def __init__(self, identification):
        self._name                = identification
        self._bind                = INIT_BIND
        self._load                = INIT_LOAD
        self._init_rotation       = INIT_ROTATION
        self._origin_x            = INIT_ORIGIN_X
        self._origin_y            = INIT_ORIGIN_Y
        self._radius_x            = INIT_RADIUS_X
        self._radius_y            = INIT_RADIUS_Y
        self._max_rotation        = INIT_MAX_ROTATION
        self._number_of_segments  = INIT_SEGMENT_NUMBER
        self._segment_thickness   = INIT_SEGMENT_THICKNESS
        self._color_min           = INIT_COLOR_MIN
        self._color_mean          = INIT_COLOR_MEAN
        self._color_max           = INIT_COLOR_MAX
        self._mean_value          = INIT_COLOR_MEAN_VALUE
        self._fixed_font_color    = INIT_FIXED_COLOR
        self._direction           = INIT_CLOCKWISE
        self._label_font          = INIT_LABEL_FONT
        self._label_color         = INIT_LABEL_COLOR
        self._colors              = []

    def setAttribute(self, key, value):
        if key == "name":
            self._name = value
        elif key == "bind":
            self._bind = value
        elif key == "radius_x":
            self._radius_x = int(value)
        elif key == "radius_y":
            self._radius_y = int(value)
        elif key == "init_rotation":
            self._init_rotation = int(value)
        elif key == "max_rotation":
            self._max_rotation = int(value)
        elif key == "number_of_segments":
            self._number_of_segments = int(value)
        elif key == "segment_thickness":
            self._segment_thickness = int(value)
        elif key == "color_min":
            self._color_min = value
            self.make_colors()
        elif key == "color_mean":
            self._color_mean = value
            self.make_colors()
        elif key == "color_max":
            self._color_max = value
            self.make_colors()
        elif key == "mean_value":
            self._mean_value = value
            self.make_colors()
        elif key == "fixed_font_color":
            self._fixed_font_color = bool(value)
        elif key == "meter_direction":
            self._direction = bool(value)
        elif key == "label_font":
            self._label_font = value
        elif key == "label_color":
            self._label_color = value
        else:
            return False

        return True

    def make_colors(self):
      self._colors = []
      r1, g1, b1  = int(self._color_min[1:3],16),\
                    int(self._color_min[3:5],16),\
                    int(self._color_min[5:7],16)
      r2, g2, b2  = int(self._color_mean[1:3],16),\
                    int(self._color_mean[3:5],16),\
                    int(self._color_mean[5:7],16)
      r3, g3, b3  = int(self._color_max[1:3],16),\
                    int(self._color_max[3:5],16),\
                    int(self._color_max[5:7],16)
      barrier     = int((float(self._number_of_segments)/100.0) * float(self._mean_value))

      """
      The very first color (color_min)
      """
      self._colors.append(self._color_min[0:7])

      """
      First colors in range 2...barrier-1
      """
      width = float(barrier-2)
      if width > 0.:
          dr, db, dg = float(r2 - r1), float(b2 - b1), float(g2 - g1)
          step_r, step_g, step_b = dr/width, dg/width, db/width
          for i in range(1,barrier-1):
              str_r, str_g, str_b = "","",""
              # R
              if len(hex(int(r1 + i*step_r))[2:4]) < 2:
                  str_r = "0" + hex(int(r1 + i*step_r))[2:4]
              else:
                  str_r = hex(int(r1 + i*step_r))[2:4]
              # G
              if len(hex(int(g1 + i*step_g))[2:4]) < 2:
                  str_g = "0" + hex(int(g1 + i*step_g))[2:4]
              else:
                  str_g = hex(int(g1 + i*step_g))[2:4]
              # B
              if len(hex(int(b1 + i*step_b))[2:4]) < 2:
                  str_b = "0" + hex(int(b1 + i*step_b))[2:4]
              else:
                  str_b = hex(int(b1 + i*step_b))[2:4]
              # append to list of colors
              self._colors.append("#%s%s%s" % (str_r, str_g, str_b))

      """
      The color used for the mean value
      """
      self._colors.append(self._color_mean[0:7])

      """
      The last colors in range barrier+1, number_if_segments-1
      """
      width = float(self._number_of_segments-barrier-1)
      if width > 0:
          dr, db, dg = float(r3 - r2), float(b3 - b2), float(g3 - g2)
          step_r, step_g, step_b = dr/width, dg/width,db/width
          for i in range(1,self._number_of_segments-barrier):
              str_r, str_g, str_b = "","",""
              # R
              if len(hex(int(r2 + i*step_r))[2:4]) < 2:
                  str_r = "0" + hex(int(r2 + i*step_r))[2:4]
              else:
                  str_r = hex(int(r2 + i*step_r))[2:4]
              # G
              if len(hex(int(g2 + i*step_g))[2:4]) < 2:
                  str_g = "0" + hex(int(g2 + i*step_g))[2:4]
              else:
                  str_g = hex(int(g2 + i*step_g))[2:4]
              # B
              if len(hex(int(b2 + i*step_b))[2:4]) < 2:
                  str_b = "0" + hex(int(b2 + i*step_b))[2:4]
              else:
                  str_b = hex(int(b2 + i*step_b))[2:4]
              # append to list of colors
              self._colors.append("#%s%s%s" % (str_r, str_g, str_b))

      """
      The very last color
      """
      self._colors.append(self._color_max[0:7])

    #
    # initializes the svg, i.e. creates it from given attributes
    # 
    def init_svg(self):
        curr_ang = self._init_rotation
        step_angle = float(self._max_rotation)/self._number_of_segments

        # create the svg image
        svg_code = "<svg width=\"100\" height=\"100\">"
        elements = range(0, self._number_of_segments)
        if not self._direction: elements.reverse()

        for i in elements:
            sin_1 = sine(curr_ang)
            cos_1 = cosine(curr_ang)
            sin_2 = sine(curr_ang + step_angle)
            cos_2 = cosine(curr_ang + step_angle)

            x1 = self._origin_x + cos_1 * (self._radius_x)
            y1 = self._origin_y + sin_1 * (self._radius_y)
            x2 = self._origin_x + cos_2 * (self._radius_x)
            y2 = self._origin_x + sin_2 * (self._radius_y)
            x3 = self._origin_x + cos_2 * (self._radius_x - self._segment_thickness)
            y3 = self._origin_x + sin_2 * (self._radius_y - self._segment_thickness)
            x4 = self._origin_x + cos_1 * (self._radius_x - self._segment_thickness)
            y4 = self._origin_y + sin_1 * (self._radius_y - self._segment_thickness)
            svg_code += SVG_PATH % (i+1, x4, y4, x1, y1, self._radius_x,\
                                    self._radius_y, x2, y2, x3, y3, self._radius_x,\
                                    self._radius_y, x4, y4)
            curr_ang += step_angle
        svg_code += "</svg>"

        # init and update the svg dom
        getattr(Dsp, "CircleMeterCanvas")[0].graphics = svg_code
        getattr(Dsp, "CircleMeterCanvas")[0].dom.update()

    def update_meter(self):
        border      = int((float(self._number_of_segments) / 100.0) * float(self._load))

        for i in range(0, border):
            if i < len(self._colors):
                getattr(Dsp, "CircleMeterCanvas")[0].dom.get("bar_%d" % (i+1))["fill"] = self._colors[i]
            else:
                getattr(Dsp, "CircleMeterCanvas")[0].dom.get("bar_%d" % (i+1))["fill"] = "#ffff00"

            getattr(Dsp, "CircleMeterCanvas")[0].dom.get("bar_%d" % (i+1))["stroke"]       = "None"
            getattr(Dsp, "CircleMeterCanvas")[0].dom.get("bar_%d" % (i+1))["stroke-width"] = 0

        if border < self._number_of_segments:
            for i in range(border, self._number_of_segments):
                getattr(Dsp, "CircleMeterCanvas")[0].dom.get("bar_%d" % (i+1))["fill"]         = "#333344"
                getattr(Dsp, "CircleMeterCanvas")[0].dom.get("bar_%d" % (i+1))["stroke"]       = "#666666"
                getattr(Dsp, "CircleMeterCanvas")[0].dom.get("bar_%d" % (i+1))["stroke-width"] = 1

        if not self._fixed_font_color:
            getattr(Dsp, "CircleMeterLabel")[0].color = self._colors[border]

        getattr(Dsp, "CircleMeterCanvas")[0].dom.update()

main()
